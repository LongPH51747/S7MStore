import React, { createContext, useContext, useState, useEffect, useRef } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import { API_ENDPOINTS, API_HEADERS, API_BASE_URL } from '../config/api';
import PushNotification from 'react-native-push-notification';
import { Platform, PermissionsAndroid, AppState } from 'react-native';

const NotificationContext = createContext();

export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);
  const [showPopup, setShowPopup] = useState(false);
  const [currentNotification, setCurrentNotification] = useState(null);
  const [lastProductCount, setLastProductCount] = useState(0);
  const [lastProductIds, setLastProductIds] = useState([]);
  const [notifiedProductIds, setNotifiedProductIds] = useState([]); // Track ƒë√£ th√¥ng b√°o
  const [notifiedOrderIds, setNotifiedOrderIds] = useState([]); // Track order ƒë√£ th√¥ng b√°o
  const [lastOrderIds, setLastOrderIds] = useState([]); // Track order IDs
  
  // ‚úÖ NEW: Single notification processing tracker
  const [processingNotifications, setProcessingNotifications] = useState(new Set());
  const processingRef = useRef(new Set());

  // Refs for debouncing and control
  const isCheckingRef = useRef(false);
  const isCheckingOrdersRef = useRef(false); // Prevent multiple order checks
  const lastCheckRef = useRef(0); // Debounce check calls
  const lastOrderCheckRef = useRef(0); // Debounce order checks
  const lastNotificationRef = useRef(0); // Track last notification time
  
  // ‚úÖ FIX: Missing interval refs
  const intervalRef = useRef(null);
  const orderIntervalRef = useRef(null);

  // ‚úÖ NEW: Background monitoring state
  const [appState, setAppState] = useState(AppState.currentState);
  const backgroundTaskRef = useRef(null);
  const backgroundIntervalRef = useRef(null);
  const lastBackgroundCheckRef = useRef(0);

  // Kh·ªüi t·∫°o khi app start
  useEffect(() => {
    const initializeApp = async () => {
      // Setup push notifications with permissions
      await configurePushNotifications();
      
      await initializeNotifications();
      startPolling();
      
      // ‚úÖ NEW: Setup background monitoring
      setupBackgroundMonitoring();
    };
    
    initializeApp();
    
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
      if (orderIntervalRef.current) {
        clearInterval(orderIntervalRef.current);
      }
      
      // ‚úÖ NEW: Cleanup background monitoring
      cleanupBackgroundMonitoring();
    };
  }, []);

  // ‚úÖ REQUEST NOTIFICATION PERMISSIONS
  const requestNotificationPermissions = async () => {
    try {
      console.log('üîê Requesting notification permissions...');
      
      if (Platform.OS === 'android') {
        const SDK_INT = Platform.constants.Release;
        console.log('üì± Android SDK version:', SDK_INT);
        
        if (SDK_INT >= 13) { // Android 13+
          console.log('üì± Android 13+ detected, requesting POST_NOTIFICATIONS permission...');
          try {
            const granted = await PermissionsAndroid.request(
              PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,
              {
                title: 'S7M Store Th√¥ng B√°o',
                message: 'App c·∫ßn quy·ªÅn th√¥ng b√°o ƒë·ªÉ g·ª≠i th√¥ng b√°o v·ªÅ s·∫£n ph·∫©m m·ªõi v√† ƒë∆°n h√†ng.',
                buttonNeutral: 'H·ªèi Sau',
                buttonNegative: 'T·ª´ Ch·ªëi',
                buttonPositive: 'ƒê·ªìng √ù',
              }
            );
            
            if (granted === PermissionsAndroid.RESULTS.GRANTED) {
              console.log('‚úÖ Notification permission granted');
              return true;
            } else {
              console.warn('‚ö†Ô∏è Notification permission denied');
              return false;
            }
          } catch (err) {
            console.error('‚ùå Error requesting notification permission:', err);
            return false;
          }
        } else {
          console.log('üì± Android < 13, permissions handled automatically via manifest');
          return true;
        }
      } else if (Platform.OS === 'ios') {
        console.log('üì± iOS detected, permissions will be requested via PushNotification.configure');
        return true;
      }
      
      return true;
    } catch (error) {
      console.error('‚ùå Error in requestNotificationPermissions:', error);
      return false;
    }
  };

  // Configure push notification settings
  const configurePushNotifications = async () => {
    console.log('üîß Configuring push notifications...');
    
    // Request permissions first
    const hasPermission = await requestNotificationPermissions();
    console.log('üîê Permission result:', hasPermission);
    
    if (!hasPermission) {
      console.warn('‚ö†Ô∏è Notification permissions not granted, notifications may not work');
    }
    
    // Create notification channel for Android
    PushNotification.createChannel(
      {
        channelId: "s7mstore-notifications", // (required)
        channelName: "S7M Store Notifications", // (required)
        channelDescription: "Th√¥ng b√°o t·ª´ S7M Store v·ªÅ s·∫£n ph·∫©m m·ªõi v√† ƒë∆°n h√†ng", // (optional) default: undefined.
        playSound: true, // (optional) default: true
        soundName: "default", // (optional) See `soundName` parameter of `localNotification` function
        importance: 4, // (optional) default: 4. Int value of the Android notification importance
        vibrate: true, // (optional) default: true. Creates the default vibration patten if true.
      },
      (created) => console.log(`üîß Push notification channel created: ${created}`) // (optional) callback returns whether the channel was created, false means it already existed.
    );

          // ENHANCED: Check if we can create channel
      console.log('üîß Attempting to create notification channel...');
      
      // Configure push notification
      PushNotification.configure({
      // (optional) Called when Token is generated (iOS and Android)
      onRegister: function (token) {
        console.log("üì± Push Notification TOKEN:", token);
      },

      // (required) Called when a remote is received or opened, or local notification is opened
      onNotification: function (notification) {
        console.log("üì≤ Push Notification received:", notification);
        
        // Handle notification tap - Deep linking to notification screen
        if (notification.userInteraction) {
          console.log("üëÜ User tapped notification");
          console.log("üìã Notification data:", notification);
          
          // Get target screen from userInfo
          const targetScreen = notification.userInfo?.screen || 'NotificationScreen';
          const action = notification.userInfo?.action || 'open_notifications';
          
          console.log("üéØ Target screen:", targetScreen, "Action:", action);
          
          // Store notification data for navigation when app becomes active
          global.pendingNotificationNavigation = {
            screen: targetScreen,
            action: action,
            timestamp: Date.now()
          };
          
          console.log("‚úÖ Notification navigation queued for when app becomes active");
        }
      },

      // (optional) Called when Registered Action is pressed and invokeApp is false, if true onNotification will be called (Android)
      onAction: function (notification) {
        console.log("üé¨ Push Notification action:", notification.action);
      },

      // (optional) Called when the user fails to register for remote notifications. Typically occurs when APNS is having issues, or the device is a simulator. (iOS)
      onRegistrationError: function(err) {
        console.error("‚ùå Push Notification registration error:", err.message, err);
      },

      // IOS ONLY (optional): default: all - Permissions to register.
      permissions: {
        alert: true,
        badge: true,
        sound: true,
      },

      // Should the initial notification be popped automatically
      // default: true
      popInitialNotification: true,

      /**
       * (optional) default: true
       * - Specified if permissions (ios) and token (android and ios) will requested or not,
       * - if not, you must call PushNotification.requestPermissions() later
       * - if you are not using remote notification or do not have Firebase installed, use this:
       *     requestPermissions: Platform.OS === 'ios'
       */
      requestPermissions: Platform.OS === 'ios',
    });

    console.log('‚úÖ Push notifications configured successfully');
  };

  // Kh·ªüi t·∫°o notifications t·ª´ AsyncStorage
  const initializeNotifications = async () => {
    try {
      console.log('üîÑ Initializing notifications from AsyncStorage...');
      const savedNotifications = await AsyncStorage.getItem('notifications');
      const savedProductCount = await AsyncStorage.getItem('lastProductCount');
      const savedProductIds = await AsyncStorage.getItem('lastProductIds');
      const savedNotifiedIds = await AsyncStorage.getItem('notifiedProductIds');
      const savedOrderIds = await AsyncStorage.getItem('lastOrderIds');
      const savedNotifiedOrderIds = await AsyncStorage.getItem('notifiedOrderIds');
      

      
              if (savedNotifications) {
          const notifications = JSON.parse(savedNotifications);
          console.log('üíæ Loading saved notifications:', notifications.length, 'notifications found');
          
          // CLEANUP: Remove duplicates from existing data
          const cleanedNotifications = [];
          const seenOrderIds = new Set();
          const seenProductIds = new Set();
          
          notifications.forEach(notification => {
            let isDuplicate = false;
            
            if (notification.type === 'new_order' && notification.orderId) {
              if (seenOrderIds.has(notification.orderId)) {
                isDuplicate = true;
                console.log('üßπ Removing duplicate order notification:', notification.orderId.slice(-4));
              } else {
                seenOrderIds.add(notification.orderId);
              }
            } else if (notification.type === 'new_product' && notification.productId) {
              if (seenProductIds.has(notification.productId)) {
                isDuplicate = true;
                console.log('üßπ Removing duplicate product notification:', notification.productName);
              } else {
                seenProductIds.add(notification.productId);
              }
            }
            
            if (!isDuplicate) {
              cleanedNotifications.push(notification);
            }
          });
          
          console.log('üßπ Cleaned notifications:', cleanedNotifications.length, 'remaining from', notifications.length, 'original');
          
          // Save cleaned data back to AsyncStorage
          if (cleanedNotifications.length !== notifications.length) {
            await AsyncStorage.setItem('notifications', JSON.stringify(cleanedNotifications));
            console.log('üßπ ‚úÖ Saved cleaned notifications to AsyncStorage');
          }
          
          setNotifications(cleanedNotifications);
          console.log('üíæ ‚úÖ Set notifications state with', cleanedNotifications.length, 'items');
        } else {
          console.log('üíæ No saved notifications found - starting fresh');
          setNotifications([]);
        }
      
      if (savedProductCount) {
        const count = parseInt(savedProductCount);
        setLastProductCount(count);
        console.log(`‚úÖ Loaded last product count: ${count}`);
      }

      if (savedProductIds) {
        const ids = JSON.parse(savedProductIds);
        console.log('üíæ Loading lastProductIds from AsyncStorage:', ids.length, 'items');
        console.log('üíæ First 3 lastProductIds:', ids.slice(0, 3));
        setLastProductIds(ids);
      } else {
        console.log('üíæ No lastProductIds found in AsyncStorage - starting fresh');
        setLastProductIds([]);
      }

      if (savedNotifiedIds) {
        const notifiedIds = JSON.parse(savedNotifiedIds);
        setNotifiedProductIds(notifiedIds);

      }

      if (savedOrderIds) {
        const orderIds = JSON.parse(savedOrderIds);
        setLastOrderIds(orderIds);

      }

      if (savedNotifiedOrderIds) {
        const notifiedOrderIds = JSON.parse(savedNotifiedOrderIds);
        setNotifiedOrderIds(notifiedOrderIds);

      }
    } catch (error) {
      console.error('‚ùå Error loading notifications:', error);
    }
  };

  // B·∫Øt ƒë·∫ßu polling v·ªõi notifications cho c·∫£ products v√† orders
  const startPolling = () => {

    // G·ªçi ngay l·∫ßn ƒë·∫ßu
    checkForNewProducts();
    checkForOrderStatusChanges();
    
    // Setup interval 60 gi√¢y cho products (same as orders for faster response)
    intervalRef.current = setInterval(() => {
      console.log('‚è∞ Product interval triggered');
      checkForNewProducts();
    }, 60000); // 60 gi√¢y (reduced from 90s)
    
    // Setup interval 30 gi√¢y cho orders (faster ƒë·ªÉ catch status changes)
    orderIntervalRef.current = setInterval(() => {
      console.log('‚è∞ Order interval triggered');
      checkForOrderStatusChanges();
    }, 30000); // 30 gi√¢y
    

  };

  // ‚úÖ NEW: Setup background monitoring cho notifications 
  const setupBackgroundMonitoring = () => {
    console.log('üîÑ [BACKGROUND] Setting up background monitoring...');
    
    // Listen to AppState changes
    const handleAppStateChange = (nextAppState) => {
      console.log(`üîÑ [BACKGROUND] App state changed: ${appState} ‚Üí ${nextAppState}`);
      
      if (appState.match(/inactive|background/) && nextAppState === 'active') {
        console.log('üîÑ [BACKGROUND] App came to foreground - checking for updates');
        
        // Check for pending notification navigation
        if (global.pendingNotificationNavigation) {
          console.log('üîÑ [BACKGROUND] Processing pending notification navigation');
          const pendingNav = global.pendingNotificationNavigation;
          
          // Clear the pending navigation
          global.pendingNotificationNavigation = null;
          
          // Navigate to target screen after a short delay
          setTimeout(() => {
            try {
              const targetScreen = pendingNav.screen;
              console.log('üéØ Navigating to:', targetScreen);
              
              // Use navigation service if available
              if (global.navigationService) {
                global.navigationService.navigate(targetScreen);
                console.log(`‚úÖ Successfully navigated to ${targetScreen} from notification tap`);
              } else if (global._navigator) {
                global._navigator.navigate(targetScreen);
                console.log(`‚úÖ Successfully navigated to ${targetScreen} from notification tap`);
              } else {
                console.log('‚ö†Ô∏è Navigation service not available, notification navigation skipped');
              }
            } catch (error) {
              console.error('‚ùå Error navigating from notification:', error);
            }
          }, 500);
        }
        
        // App came to foreground - check immediately
        checkForNewProducts();
        checkForOrderStatusChanges();
        
        // Stop background tasks
        stopBackgroundTasks();
        
      } else if (appState === 'active' && nextAppState.match(/inactive|background/)) {
        console.log('üîÑ [BACKGROUND] App went to background - starting background tasks');
        // App went to background - start background checking
        startBackgroundTasks();
      }
      
      setAppState(nextAppState);
    };

    // Add event listener
    const subscription = AppState.addEventListener('change', handleAppStateChange);
    
    console.log('‚úÖ [BACKGROUND] Background monitoring setup completed');
    
    return subscription;
  };

  // ‚úÖ NEW: Start background tasks khi app ·ªü background
  const startBackgroundTasks = () => {
    console.log('üïê [BACKGROUND] Starting background notification checks...');
    
    // Clear any existing background interval
    if (backgroundIntervalRef.current) {
      clearInterval(backgroundIntervalRef.current);
    }
    
    // ‚úÖ BACKGROUND CHECK: Every 2 minutes (limited background time)
    backgroundIntervalRef.current = setInterval(() => {
      const now = Date.now();
      
      // Check if we've been in background too long (iOS limits to ~30 seconds, Android varies)
      if (now - lastBackgroundCheckRef.current < 120000) { // 2 minutes limit
        console.log('üïê [BACKGROUND] Background check triggered');
        
        // Quick background check - only new products
        checkForNewProductsBackground();
        checkForOrderStatusChangesBackground();
        
        lastBackgroundCheckRef.current = now;
      } else {
        console.log('‚è∏Ô∏è [BACKGROUND] Background time limit reached, stopping checks');
        stopBackgroundTasks();
      }
    }, 120000); // 2 minutes interval for background
    
    // Set initial background check time
    lastBackgroundCheckRef.current = Date.now();
    
    console.log('‚úÖ [BACKGROUND] Background tasks started');
  };

  // ‚úÖ NEW: Stop background tasks
  const stopBackgroundTasks = () => {
    if (backgroundIntervalRef.current) {
      clearInterval(backgroundIntervalRef.current);
      backgroundIntervalRef.current = null;
      console.log('‚èπÔ∏è [BACKGROUND] Background tasks stopped');
    }
  };

  // ‚úÖ NEW: Cleanup background monitoring
  const cleanupBackgroundMonitoring = () => {
    stopBackgroundTasks();
    // AppState listener will be cleaned up automatically by React
    console.log('üßπ [BACKGROUND] Background monitoring cleaned up');
  };

  // ‚úÖ ENHANCED: Check for new products v·ªõi improved error handling
  const checkForNewProducts = async () => {
    // ENHANCED Debounce - ch·ªâ check n·∫øu kh√¥ng ƒëang check v√† ƒë√£ qua 20s t·ª´ l·∫ßn check tr∆∞·ªõc
    const now = Date.now();
    if (isCheckingRef.current || (now - lastCheckRef.current) < 20000) {
      console.log('üîÑ Product check skipped - debounce active (last check:', new Date(lastCheckRef.current).toLocaleTimeString(), ')');
      return;
    }

    console.log('üîç Checking for new products...');
    console.log('üîç [FOREGROUND] Foreground product check initiated');

    try {
      isCheckingRef.current = true;
      lastCheckRef.current = now;
      
      console.log('üåê Calling products API:', API_ENDPOINTS.PRODUCTS.GET_ALL);
      
      // ‚úÖ SIMPLIFIED: Remove AbortController to eliminate AbortError
      const response = await axios.get(API_ENDPOINTS.PRODUCTS.GET_ALL, {
        headers: API_HEADERS,
        timeout: 15000, // 15s simple timeout
      });

      console.log('‚úÖ Products API response:', response.data ? response.data.length : 0, 'products found');

      if (response.data && response.data.length > 0) {
        const currentProducts = response.data;
        const currentProductCount = currentProducts.length;
        const currentProductIds = currentProducts.map(p => p._id || p.id);
        
        console.log('üì¶ Current Products:', currentProductCount, 'products found');
        console.log('üì¶ Last Product IDs:', lastProductIds.length, 'saved products');
        console.log('üì¶ Notified Product IDs:', notifiedProductIds.length, 'already notified');

        // Detect new products b·∫±ng c√°ch so s√°nh IDs
        if (lastProductIds.length > 0) {
          const newProductIds = currentProductIds.filter(id => !lastProductIds.includes(id));
          // ‚úÖ CRITICAL: Filter out nh·ªØng s·∫£n ph·∫©m ƒë√£ th√¥ng b√°o r·ªìi
          const unnotifiedProductIds = newProductIds.filter(id => !notifiedProductIds.includes(id));
          
          console.log('üÜï New Product IDs found:', newProductIds.length);
    
          console.log('üîç Actual unnotified Product IDs:', unnotifiedProductIds);

          if (unnotifiedProductIds.length > 0) {
            console.log('üéØ Processing unnotified products:', unnotifiedProductIds);
            
            // ‚úÖ PROCESS ONLY NEW & UNNOTIFIED PRODUCTS
            const unnotifiedProducts = currentProducts.filter(p => 
              unnotifiedProductIds.includes(p._id || p.id)
            );
            
            console.log('üéØ Filtered unnotified products:', unnotifiedProducts.length, 'items');
            console.log('üéØ Unnotified product names:', unnotifiedProducts.map(p => p.product_name).slice(0, 5));

            // ‚úÖ ENHANCED: Group by product name to avoid duplicate variants and similar products
            const groupedProducts = unnotifiedProducts.reduce((acc, product) => {
              // Use product name as primary grouping key (more reliable than base_product_id)
              const productName = (product.product_name || product.productName || '').trim().toLowerCase();
              const baseId = product.base_product_id || productName || product._id;
              
              console.log(`üîç Grouping product: ${product.product_name} | Base ID: ${baseId}`);
              
              if (!acc[baseId]) {
                acc[baseId] = {
                  id: product._id,
                  name: product.product_name || product.productName,
                  price: product.product_price || 0,
                  image: product.product_image,
                  variants: 1,
                  baseId: baseId
                };
                console.log(`‚úÖ Created new group for: ${product.product_name}`);
              } else {
                acc[baseId].variants++;
                console.log(`üì¶ Added to existing group: ${product.product_name} (${acc[baseId].variants} variants)`);
              }
              return acc;
            }, {});

            const uniqueProducts = Object.values(groupedProducts);
            console.log('üì¶ Grouped products:', uniqueProducts.length, 'unique products from', unnotifiedProducts.length, 'items');
            console.log('üì¶ Unique product details:', uniqueProducts.map(p => `${p.name} (${p.variants} variants)`));

            // ‚úÖ LIMIT: Maximum 1 notification per unique product name per session
            const sessionNotifiedNames = new Set();
            const validProducts = uniqueProducts.filter(product => {
              const normalizedName = (product.name || '').trim().toLowerCase();
              if (sessionNotifiedNames.has(normalizedName)) {
                console.log(`‚ö†Ô∏è Already notified for product name this session: ${product.name}`);
                return false;
              }
              sessionNotifiedNames.add(normalizedName);
              return true;
            });

            console.log('üéØ Final valid products after session dedup:', validProducts.length);
            console.log('üéØ Will create notifications for:', validProducts.map(p => p.name));

            if (validProducts.length === 0) {
              console.log('üìù No valid products to notify after deduplication');
              return;
            }

            // ‚úÖ SEQUENTIAL PROCESSING - ONE AT A TIME AS REQUESTED
            for (const product of validProducts) {
        
              
              // ‚úÖ CHECK: Skip if already notified (double check)
              if (notifiedProductIds.includes(product.id)) {
                console.log('‚ö†Ô∏è Product already notified, skipping:', product.name);
                continue;
              }

              await processNewProductNotification(product);
              
              // ‚úÖ IMMEDIATE: Mark as notified to prevent duplicates
              await addToNotifiedList(product.id);
              
              // ‚úÖ AS REQUESTED: Wait before next notification
              console.log('‚è∏Ô∏è Waiting before next notification...');
              await new Promise(resolve => setTimeout(resolve, 2000)); // 2s delay
            }
          } else {
            console.log('üìù All new products already notified');
          }
        } else {
          // First time checking products - check for very recent products only
          console.log('üìù First time checking products - checking for very recent products');
          const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
          const recentProducts = currentProducts.filter(product => {
            const createdAt = new Date(product.createdAt || product.created_at).getTime();
            return createdAt > tenMinutesAgo;
          });

          console.log('üÜï Recent products (last 10 min):', recentProducts.length);

          if (recentProducts.length === 0) {
            console.log('üìù No recent products found in last 10 minutes');
          } else {
            // Process recent products same as new products
            for (const recentProduct of recentProducts) {
              console.log('üîî Creating first-time product notification:', recentProduct.product_name);
              
              await processNewProductNotification({
                id: recentProduct._id,
                name: recentProduct.product_name,
                price: recentProduct.product_price || 0,
                image: recentProduct.product_image
              });
              
              await addToNotifiedList(recentProduct._id);
              await new Promise(resolve => setTimeout(resolve, 2000)); // 2s delay
            }
          }
        }

        // Save current state
        setLastProductIds(currentProductIds);
        await AsyncStorage.setItem('lastProductIds', JSON.stringify(currentProductIds));
        
        console.log('üíæ SAVED to AsyncStorage - Count:', currentProductCount, ', ProductIDs:', currentProductIds.length, 'items');
        console.log('üíæ SAVED First 3 ProductIDs:', currentProductIds.slice(0, 3));
      }

      console.log('üîö Product check completed');
    } catch (error) {
      // ‚úÖ BETTER ERROR HANDLING
      if (error.name === 'AbortError') {
        console.warn('‚ö†Ô∏è Product API request was aborted (timeout)');
      } else if (error.code === 'ECONNABORTED') {
        console.warn('‚ö†Ô∏è Product API request timed out');
      } else {
        console.error('‚ùå Error checking for new products:', error.message);
      }
    } finally {
      isCheckingRef.current = false;
    }
  };

  // ‚úÖ NEW: Check for new products v·ªõi improved error handling (background)
  const checkForNewProductsBackground = async () => {
    // ENHANCED Debounce - ch·ªâ check n·∫øu kh√¥ng ƒëang check v√† ƒë√£ qua 20s t·ª´ l·∫ßn check tr∆∞·ªõc
    const now = Date.now();
    if (isCheckingRef.current || (now - lastCheckRef.current) < 20000) {
      console.log('üîÑ Background Product check skipped - debounce active (last check:', new Date(lastCheckRef.current).toLocaleTimeString(), ')');
      return;
    }

    console.log('üîç Background checking for new products...');
    console.log('üîç [BACKGROUND] Background product check initiated');

    // ‚úÖ PREVENT BACKGROUND + FOREGROUND CONFLICT
    if (appState === 'active') {
      console.log('‚ö†Ô∏è [BACKGROUND] App is active, skipping background check');
      return;
    }

    try {
      isCheckingRef.current = true;
      lastCheckRef.current = now;
      
      console.log('üåê Background calling products API:', API_ENDPOINTS.PRODUCTS.GET_ALL);
      
      // ‚úÖ SIMPLIFIED: Remove AbortController to eliminate AbortError
      const response = await axios.get(API_ENDPOINTS.PRODUCTS.GET_ALL, {
        headers: API_HEADERS,
        timeout: 15000, // 15s simple timeout
      });

      console.log('‚úÖ Background Products API response:', response.data ? response.data.length : 0, 'products found');

      if (response.data && response.data.length > 0) {
        const currentProducts = response.data;
        const currentProductCount = currentProducts.length;
        const currentProductIds = currentProducts.map(p => p._id || p.id);
        
        console.log('üì¶ Background Current Products:', currentProductCount, 'products found');
        console.log('üì¶ Background Last Product IDs:', lastProductIds.length, 'saved products');
        console.log('üì¶ Background Notified Product IDs:', notifiedProductIds.length, 'already notified');

        // Detect new products b·∫±ng c√°ch so s√°nh IDs
        if (lastProductIds.length > 0) {
          const newProductIds = currentProductIds.filter(id => !lastProductIds.includes(id));
          // ‚úÖ CRITICAL: Filter out nh·ªØng s·∫£n ph·∫©m ƒë√£ th√¥ng b√°o r·ªìi
          const unnotifiedProductIds = newProductIds.filter(id => !notifiedProductIds.includes(id));
          
          console.log('üÜï Background New Product IDs found:', newProductIds.length);
          console.log('üîî Background Unnotified Product IDs:', unnotifiedProductIds.length);
          console.log('üîç Background Actual unnotified Product IDs:', unnotifiedProductIds);

          if (unnotifiedProductIds.length > 0) {
            console.log('üéØ Background Processing unnotified products:', unnotifiedProductIds);
            
            // ‚úÖ PROCESS ONLY NEW & UNNOTIFIED PRODUCTS
            const unnotifiedProducts = currentProducts.filter(p => 
              unnotifiedProductIds.includes(p._id || p.id)
            );
            
            console.log('üéØ Background Filtered unnotified products:', unnotifiedProducts.length, 'items');

            // ‚úÖ ENHANCED: Group by base_product_id to avoid duplicate variants
            const groupedProducts = unnotifiedProducts.reduce((acc, product) => {
              const baseId = product.base_product_id || product._id;
              if (!acc[baseId]) {
                acc[baseId] = {
                  id: product._id,
                  name: product.product_name || product.productName,
                  price: product.product_price || 0,
                  image: product.product_image,
                  variants: 1
                };
              } else {
                acc[baseId].variants++;
              }
              return acc;
            }, {});

            const uniqueProducts = Object.values(groupedProducts);
            console.log('üì¶ Background Grouped products:', uniqueProducts.length, 'unique products from', unnotifiedProducts.length, 'items');

            // ‚úÖ SEQUENTIAL PROCESSING - ONE AT A TIME AS REQUESTED
            for (const product of uniqueProducts) {
              console.log('üîî Background PROCESSING SINGLE PRODUCT NOTIFICATION');
              
              // ‚úÖ CHECK: Skip if already notified (double check)
              if (notifiedProductIds.includes(product.id)) {
                console.log('‚ö†Ô∏è Background Product already notified, skipping:', product.name);
                continue;
              }

              await processNewProductNotification(product);
              
              // ‚úÖ IMMEDIATE: Mark as notified to prevent duplicates
              await addToNotifiedList(product.id);
              
              // ‚úÖ AS REQUESTED: Wait before next notification
              console.log('‚è∏Ô∏è Background Waiting before next notification...');
              await new Promise(resolve => setTimeout(resolve, 2000)); // 2s delay
            }
          } else {
            console.log('üìù Background All new products already notified');
          }
        } else {
          // First time checking products - check for very recent products only
          console.log('üìù Background First time checking products - checking for very recent products');
          const tenMinutesAgo = Date.now() - (10 * 60 * 1000);
          const recentProducts = currentProducts.filter(product => {
            const createdAt = new Date(product.createdAt || product.created_at).getTime();
            return createdAt > tenMinutesAgo;
          });

          console.log('üÜï Background Recent products (last 10 min):', recentProducts.length);

          if (recentProducts.length === 0) {
            console.log('üìù Background No recent products found in last 10 minutes');
          } else {
            // Process recent products same as new products
            for (const recentProduct of recentProducts) {
              console.log('üîî Background Creating first-time product notification:', recentProduct.product_name);
              
              await processNewProductNotification({
                id: recentProduct._id,
                name: recentProduct.product_name,
                price: recentProduct.product_price || 0,
                image: recentProduct.product_image
              });
              
              await addToNotifiedList(recentProduct._id);
              await new Promise(resolve => setTimeout(resolve, 2000)); // 2s delay
            }
          }
        }

        // Save current state
        setLastProductIds(currentProductIds);
        await AsyncStorage.setItem('lastProductIds', JSON.stringify(currentProductIds));
        
        console.log('üíæ Background SAVED to AsyncStorage - Count:', currentProductCount, ', ProductIDs:', currentProductIds.length, 'items');
        console.log('üíæ Background SAVED First 3 ProductIDs:', currentProductIds.slice(0, 3));
      }

      console.log('üîö Background Product check completed');
    } catch (error) {
      // ‚úÖ BETTER ERROR HANDLING
      if (error.name === 'AbortError') {
        console.warn('‚ö†Ô∏è Background Product API request was aborted (timeout)');
      } else if (error.code === 'ECONNABORTED') {
        console.warn('‚ö†Ô∏è Background Product API request timed out');
      } else {
        console.error('‚ùå Error checking for new products:', error.message);
      }
    } finally {
      isCheckingRef.current = false;
    }
  };

  // ‚úÖ NEW: Check if notification is already being processed (ONE-TIME PROCESSING)
  const isNotificationProcessing = (id, type) => {
    const key = `${type}_${id}`;
    return processingRef.current.has(key);
  };

  // ‚úÖ NEW: Mark notification as being processed
  const markNotificationProcessing = (id, type) => {
    const key = `${type}_${id}`;
    processingRef.current.add(key);
    setProcessingNotifications(new Set(processingRef.current));
    console.log(`üîí [LOCK] Marking ${key} as processing`);
  };

  // ‚úÖ NEW: Mark notification as completed
  const markNotificationCompleted = (id, type) => {
    const key = `${type}_${id}`;
    processingRef.current.delete(key);
    setProcessingNotifications(new Set(processingRef.current));
    console.log(`üîì [UNLOCK] Marking ${key} as completed`);
  };

  // ‚úÖ NEW: Process single product notification with one-time guarantee
  const processNewProductNotification = async (newProduct) => {
    const productId = newProduct.id;
    
    // ‚úÖ CRITICAL: Check if already processing
    if (isNotificationProcessing(productId, 'product')) {
      console.log(`‚ö†Ô∏è [SKIP] Product ${productId} already being processed`);
      return;
    }

    // ‚úÖ CRITICAL: Check if already notified
    if (notifiedProductIds.includes(productId)) {
      console.log(`‚ö†Ô∏è [SKIP] Product ${productId} already notified`);
      return;
    }

    try {
      // ‚úÖ LOCK: Mark as processing to prevent duplicates
      markNotificationProcessing(productId, 'product');
      
      console.log(`üìù [ONCE] Processing notification for: ${newProduct.name}`);
      
      const notification = {
        id: Date.now() + Math.random(),
        type: 'new_product',
        title: 'S·∫£n Ph·∫©m M·ªõi',
        message: `${newProduct.name} v·ª´a ƒë∆∞·ª£c th√™m v√†o c·ª≠a h√†ng`,
        productId: productId,
        productName: newProduct.name,
        productImage: newProduct.image ? `${API_BASE_URL}${newProduct.image}` : null,
        productPrice: newProduct.price,
        timestamp: new Date().toLocaleTimeString('vi-VN'),
        isRead: false,
        createdAt: Date.now()
      };

      // ‚úÖ THEO Y√äU C·∫¶U: Th√¥ng b√°o trong app TR∆Ø·ªöC
      console.log('üì± [STEP 1] Adding internal notification first...');
      await addNotification(notification);
      
      // ‚úÖ THEO Y√äU C·∫¶U: ƒê·ª£i 1 ch√∫t r·ªìi g·ª≠i system notification
      console.log('‚è∏Ô∏è [WAIT] Waiting before system notification...');
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      console.log('üì± [STEP 2] Now sending system notification...');
      await showNotificationPopup(notification);
      
      // ‚úÖ MARK as notified immediately
      await addToNotifiedList(productId);
      
      console.log('‚úÖ [COMPLETE] Product notification process finished - ONE TIME ONLY');
      
    } catch (error) {
      console.error('‚ùå Error processing product notification:', error);
    } finally {
      // ‚úÖ UNLOCK: Always unlock even if error
      markNotificationCompleted(productId, 'product');
    }
  };

  // Th√™m notification with duplicate check
  const addNotification = async (notification) => {
    try {
      console.log('üíæ Adding notification:', notification.title, 'Type:', notification.type);
      console.log('üîç Call stack trace: addNotification called for', notification.type, 'with ID:', notification.orderId || notification.productId);
      
      // CRITICAL: Load current notifications t·ª´ AsyncStorage ƒë·ªÉ tr√°nh race condition
      const currentNotificationsStr = await AsyncStorage.getItem('notifications');
      const currentNotifications = currentNotificationsStr ? JSON.parse(currentNotificationsStr) : [];
      
      console.log('üíæ Current notifications in storage:', currentNotifications.length);
      
      // ENHANCED: Check for duplicates
      let isDuplicate = false;
      
      if (notification.type === 'new_order' && notification.orderId) {
        // Check duplicate order by orderId
        isDuplicate = currentNotifications.some(n => 
          n.type === 'new_order' && n.orderId === notification.orderId
        );
        console.log('üîç Order duplicate check:', isDuplicate ? 'FOUND' : 'NONE');
      } else if (notification.type === 'new_product' && notification.productId) {
        // Check duplicate product by productId (not variant!)
        isDuplicate = currentNotifications.some(n => 
          n.type === 'new_product' && n.productId === notification.productId
        );
        console.log('üîç Product duplicate check:', isDuplicate ? 'FOUND' : 'NONE');
      }
      
      if (isDuplicate) {
        console.log('‚ö†Ô∏è Duplicate notification detected - skipping add');
        console.log('üö´ CRITICAL: This should not happen if new logic is working correctly!');
        console.log('üîç Existing notification with same ID:', 
          currentNotifications.find(n => 
            (notification.type === 'new_order' && n.orderId === notification.orderId) ||
            (notification.type === 'new_product' && n.productId === notification.productId)
          )
        );
        return; // Don't add duplicate
      }
      
      // Merge v·ªõi notifications t·ª´ AsyncStorage (reliable h∆°n state)
      const updatedNotifications = [notification, ...currentNotifications];
      console.log('üíæ Total notifications after add:', updatedNotifications.length);
      
      setNotifications(updatedNotifications);
      await AsyncStorage.setItem('notifications', JSON.stringify(updatedNotifications));
      console.log('üíæ Successfully saved to AsyncStorage');
    } catch (error) {
      console.error('Error saving notification:', error);
    }
  };

  // ‚úÖ SYSTEM PUSH NOTIFICATION - SIMPLIFIED VERSION
  const showNotificationPopup = async (notification) => {
    console.log('üöÄ [SIMPLE] Starting simplified notification...');
    console.log('üöÄ [SIMPLE] Notification type:', notification.type);
    
    try {
      // ‚úÖ ULTRA SIMPLE MESSAGE - Just like you suggested
      let simpleTitle = "üì± S7M Store";
      let simpleMessage = "C√≥ s·∫£n ph·∫©m m·ªõi! B·∫•m ƒë·ªÉ xem chi ti·∫øt";
      
      if (notification.type === 'new_product') {
        simpleMessage = "üõçÔ∏è C√≥ 1 s·∫£n ph·∫©m m·ªõi! B·∫•m ƒë·ªÉ xem";
      } else if (notification.type === 'order_status_change') {
        simpleMessage = "üì¶ ƒê∆°n h√†ng c√≥ c·∫≠p nh·∫≠t! B·∫•m ƒë·ªÉ xem";
      }
      
      console.log('üì± [SIMPLE] About to send basic notification:', simpleTitle, simpleMessage);
      
      // ‚úÖ BASIC SYSTEM NOTIFICATION - NO COMPLEX SETTINGS
      PushNotification.localNotification({
        title: simpleTitle,
        message: simpleMessage,
        channelId: "s7mstore-notifications",
        
        // ‚úÖ NAVIGATION: Open app at notification screen when tapped
        userInfo: {
          screen: 'NotificationScreen',
          action: 'open_notifications'
        },
        
        // Basic settings only
        playSound: true,
        vibrate: true,
        autoCancel: true,
        largeIcon: "ic_launcher",
        
        // Simple ID
        id: Math.floor(Date.now() / 1000),
      });

      console.log('üì± ‚úÖ [SIMPLE] Basic notification sent successfully!');
      console.log('üì± üéØ [SIMPLE] When tapped ‚Üí Opens app at Profile screen');
      
      // Internal tracking
      setCurrentNotification(notification);
      setTimeout(() => {
        setCurrentNotification(null);
        console.log('‚è∞ [SIMPLE] Notification tracking cleared');
      }, 5000);
      
    } catch (error) {
      console.error('‚ùå [SIMPLE] Error in basic notification:', error);
    }
  };

  // ‚úÖ DEPRECATED: hidePopup not needed for system notifications, kept for compatibility
  const hidePopup = () => {
    console.log('‚ö†Ô∏è hidePopup called but system notifications handle this automatically');
    setShowPopup(false);
    setCurrentNotification(null);
  };

  // ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc
  const markAsRead = async (notificationId) => {
    try {
      const updatedNotifications = notifications.map(notif =>
        notif.id === notificationId ? { ...notif, isRead: true } : notif
      );
      setNotifications(updatedNotifications);
      await AsyncStorage.setItem('notifications', JSON.stringify(updatedNotifications));
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  };

  // ƒê√°nh d·∫•u t·∫•t c·∫£ ƒë√£ ƒë·ªçc
  const markAllAsRead = async () => {
    try {
      const updatedNotifications = notifications.map(notif => ({ ...notif, isRead: true }));
      setNotifications(updatedNotifications);
      await AsyncStorage.setItem('notifications', JSON.stringify(updatedNotifications));
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
    }
  };

  // ƒê·∫øm th√¥ng b√°o ch∆∞a ƒë·ªçc
  const getUnreadCount = () => {
    const unreadCount = notifications.filter(notif => !notif.isRead).length;
    console.log(`üî¢ Badge Count - Total notifications: ${notifications.length}, Unread: ${unreadCount}`);
    console.log(`üî¢ Notifications details:`, notifications.map(n => ({ 
      id: n.id, 
      title: n.title, 
      isRead: n.isRead,
      createdAt: new Date(n.createdAt).toLocaleTimeString()
    })));
    return unreadCount;
  };

  // X√≥a notification
  const deleteNotification = async (notificationId) => {
    try {
      const updatedNotifications = notifications.filter(notif => notif.id !== notificationId);
      setNotifications(updatedNotifications);
      await AsyncStorage.setItem('notifications', JSON.stringify(updatedNotifications));
      console.log('üóëÔ∏è Deleted notification:', notificationId);
    } catch (error) {
      console.error('Error deleting notification:', error);
    }
  };

  // X√≥a t·∫•t c·∫£ notifications
  const deleteAllNotifications = async () => {
    try {
      setNotifications([]);
      await AsyncStorage.setItem('notifications', JSON.stringify([]));
      console.log('üóëÔ∏è Deleted all notifications');
    } catch (error) {
      console.error('Error deleting all notifications:', error);
    }
  };

  // Clean duplicate notifications manually
  const cleanDuplicateNotifications = async () => {
    try {
      const cleanedNotifications = [];
      const seenOrderIds = new Set();
      const seenProductIds = new Set();
      
      notifications.forEach(notification => {
        let isDuplicate = false;
        
        if (notification.type === 'new_order' && notification.orderId) {
          if (seenOrderIds.has(notification.orderId)) {
            isDuplicate = true;
          } else {
            seenOrderIds.add(notification.orderId);
          }
        } else if (notification.type === 'new_product' && notification.productId) {
          if (seenProductIds.has(notification.productId)) {
            isDuplicate = true;
          } else {
            seenProductIds.add(notification.productId);
          }
        }
        
        if (!isDuplicate) {
          cleanedNotifications.push(notification);
        }
      });
      
      console.log('üßπ Manual cleanup:', cleanedNotifications.length, 'remaining from', notifications.length);
      setNotifications(cleanedNotifications);
      await AsyncStorage.setItem('notifications', JSON.stringify(cleanedNotifications));
      
      return {
        original: notifications.length,
        cleaned: cleanedNotifications.length,
        removed: notifications.length - cleanedNotifications.length
      };
    } catch (error) {
      console.error('Error cleaning notifications:', error);
      return null;
    }
  };

  // Th√™m product ID v√†o danh s√°ch ƒë√£ th√¥ng b√°o v·ªõi duplicate check
  const addToNotifiedList = async (productId) => {
    try {
      // ENHANCED: Check duplicate tr∆∞·ªõc khi th√™m
      if (notifiedProductIds.includes(productId)) {
        return;
      }
      
      const updatedNotifiedIds = [...notifiedProductIds, productId];
      setNotifiedProductIds(updatedNotifiedIds);
      await AsyncStorage.setItem('notifiedProductIds', JSON.stringify(updatedNotifiedIds));
    } catch (error) {
      console.error('Error saving notified product ID:', error);
    }
  };

  // Enhanced order checking - TRACK STATUS CHANGES cho 3 tr·∫°ng th√°i: ƒë√£ x√°c nh·∫≠n, ƒëang giao, giao th√†nh c√¥ng
  const checkForOrderStatusChanges = async (forceNotification = true) => {
    // Debounce - ch·ªâ check n·∫øu kh√¥ng ƒëang check v√† ƒë√£ qua 30s t·ª´ l·∫ßn check tr∆∞·ªõc  
    const now = Date.now();
    if (isCheckingOrdersRef.current || (now - lastOrderCheckRef.current) < 30000) {
      return;
    }

    // ‚úÖ REMOVED: No need to check showPopup for system notifications
    // if (showPopup) {
    //   return;
    // }

    try {
      isCheckingOrdersRef.current = true;
      lastOrderCheckRef.current = now;
      
      const userInfoString = await AsyncStorage.getItem('userInfo');
      if (!userInfoString) {
        return;
      }
      
      const userInfo = JSON.parse(userInfoString);
      const userId = userInfo._id;
      
      if (!userId) {
        return;
      }

      // Construct correct API URL with userId in path  
      const orderApiUrl = `${API_BASE_URL}/api/order/getByUserId/${userId}`;
      console.log('üîç Checking orders at URL:', orderApiUrl);
      console.log('üîç User ID being used:', userId);
      
      const response = await axios.get(orderApiUrl, {
        headers: API_HEADERS,
      });

      console.log('‚úÖ Orders API response:', response.data.length, 'orders found');

      if (response.data && response.data.length > 0) {
        const currentOrders = response.data;
        
        // FILTER: Ch·ªâ quan t√¢m 3 tr·∫°ng th√°i c·∫ßn th√¥ng b√°o
        const NOTIFICATION_STATUSES = ['ƒë√£ x√°c nh·∫≠n', 'ƒëang giao', 'giao th√†nh c√¥ng'];
        const ordersForNotification = currentOrders.filter(order => 
          NOTIFICATION_STATUSES.includes(order.status?.toLowerCase())
        );
        
        console.log('üì¶ Total Orders:', currentOrders.length);
        console.log('üéØ Orders with notification statuses:', ordersForNotification.length);
        console.log('üéØ Notification statuses found:', ordersForNotification.map(o => o.status));
        
        // Load saved order statuses ƒë·ªÉ compare changes
        const savedOrderStatusesStr = await AsyncStorage.getItem('orderStatuses');
        const savedOrderStatuses = savedOrderStatusesStr ? JSON.parse(savedOrderStatusesStr) : {};
        
        console.log('üíæ Saved order statuses:', Object.keys(savedOrderStatuses).length, 'orders tracked');
        
        // Check for status changes
        const statusChanges = [];
        
        for (const order of ordersForNotification) {
          const orderId = order._id;
          const currentStatus = order.status;
          const savedStatus = savedOrderStatuses[orderId];
          
          // N·∫øu status thay ƒë·ªïi ho·∫∑c order m·ªõi v·ªõi status notification
          if (savedStatus && savedStatus !== currentStatus) {
            console.log(`üîÑ Status changed for order ${orderId.slice(-4)}: ${savedStatus} ‚Üí ${currentStatus}`);
            statusChanges.push({
              orderId,
              oldStatus: savedStatus,
              newStatus: currentStatus,
              order: order
            });
          } else if (!savedStatus) {
            console.log(`üÜï New order with notification status ${orderId.slice(-4)}: ${currentStatus}`);
            statusChanges.push({
              orderId,
              oldStatus: null,
              newStatus: currentStatus,
              order: order
            });
          }
          
          // Update saved status
          savedOrderStatuses[orderId] = currentStatus;
        }
        
        console.log('üîî Status changes detected:', statusChanges.length);

        // Process status changes
        for (const change of statusChanges) {
          const { orderId, oldStatus, newStatus, order } = change;
          
          console.log('üîî Creating status change notification for order:', orderId.slice(-4));
          
          // Determine notification title based on status
          let title, message;
          switch (newStatus.toLowerCase()) {
            case 'ƒë√£ x√°c nh·∫≠n':
              title = 'ƒê∆°n H√†ng ƒê√£ X√°c Nh·∫≠n';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n`;
              break;
            case 'ƒëang giao':
              title = 'ƒê∆°n H√†ng ƒêang Giao';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒëang ƒë∆∞·ª£c giao`;
              break;
            case 'giao th√†nh c√¥ng':
              title = 'ƒê∆°n H√†ng Giao Th√†nh C√¥ng';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒë√£ giao th√†nh c√¥ng`;
              break;
            default:
              title = 'C·∫≠p Nh·∫≠t ƒê∆°n H√†ng';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} - ${newStatus}`;
          }
          
          const notification = {
            id: Date.now() + Math.random(),
            type: 'order_status_change',
            title: title,
            message: message,
            orderId: orderId,
            orderStatus: newStatus,
            oldStatus: oldStatus,
            orderTotal: order.total_amount,
            orderItems: order.orderItems?.length || 0,
            timestamp: new Date().toLocaleTimeString('vi-VN'),
            isRead: false,
            createdAt: Date.now()
          };
          
          // Check for duplicate notification
          const currentNotificationsStr = await AsyncStorage.getItem('notifications');
          const currentNotifications = currentNotificationsStr ? JSON.parse(currentNotificationsStr) : [];
          
          const isDuplicate = currentNotifications.some(n => 
            n.orderId === orderId && n.orderStatus === newStatus
          );
          
          if (isDuplicate) {
            console.log('‚ö†Ô∏è Status change notification already exists, skipping');
          } else {
            console.log('‚úÖ Creating status change notification');
            
            // ALWAYS show SYSTEM notification for order status changes  
            const now = Date.now();
            console.log(`üïí [AUTO-ORDER] Time check: Current=${now}, Last=${lastNotificationRef.current}, Diff=${now - lastNotificationRef.current}ms`);
            
            console.log(`üîî [AUTO-ORDER] Showing SYSTEM notification for status change: ${title}`);
            console.log(`üîî [AUTO-ORDER] About to call showNotificationPopup with notification:`, notification.title);
            console.log(`üîî [AUTO-ORDER] Complete notification object:`, JSON.stringify(notification, null, 2));
            
            // ‚úÖ THEO Y√äU C·∫¶U: Internal notification TR∆Ø·ªöC
            console.log(`üì± [STEP 1] Adding internal order notification first...`);
            await addNotification(notification);
            
            // ‚úÖ THEO Y√äU C·∫¶U: ƒê·ª£i 1 ch√∫t r·ªìi g·ª≠i system notification
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            try {
              console.log(`üì± [STEP 2] Now sending order system notification...`);
              await showNotificationPopup(notification);
              console.log(`‚úÖ [AUTO-ORDER] showNotificationPopup completed successfully`);
            } catch (error) {
              console.error(`‚ùå [AUTO-ORDER] showNotificationPopup failed:`, error);
            }
            
            console.log(`‚úÖ [COMPLETE] Order notification process finished`);
            
            // Update last notification time
            lastNotificationRef.current = now;
          }
        }
        
        // Save updated order statuses
        await AsyncStorage.setItem('orderStatuses', JSON.stringify(savedOrderStatuses));
        console.log('üíæ Updated order statuses saved to AsyncStorage');
        
        // If no saved statuses existed before (first time), just initialize tracking
        if (Object.keys(savedOrderStatuses).length === statusChanges.length && statusChanges.every(c => c.oldStatus === null)) {
          console.log('üìù First time checking orders - initialized status tracking for', Object.keys(savedOrderStatuses).length, 'orders');
        }
      }
    } catch (error) {
      console.error('‚ùå Error checking for new orders:', error);
      if (error.response) {
        console.error('üìù Error details - Status:', error.response.status);
        console.error('üìù Error details - Data:', error.response.data);
        console.error('üìù Error details - URL:', error.config?.url);
      }
    } finally {
      isCheckingOrdersRef.current = false;
    }
  };

  // ‚úÖ NEW: Enhanced order checking - TRACK STATUS CHANGES cho 3 tr·∫°ng th√°i: ƒë√£ x√°c nh·∫≠n, ƒëang giao, giao th√†nh c√¥ng (background)
  const checkForOrderStatusChangesBackground = async () => {
    // Debounce - ch·ªâ check n·∫øu kh√¥ng ƒëang check v√† ƒë√£ qua 30s t·ª´ l·∫ßn check tr∆∞·ªõc  
    const now = Date.now();
    if (isCheckingOrdersRef.current || (now - lastOrderCheckRef.current) < 30000) {
      return;
    }

    // ‚úÖ REMOVED: No need to check showPopup for system notifications
    // if (showPopup) {
    //   return;
    // }

    try {
      isCheckingOrdersRef.current = true;
      lastOrderCheckRef.current = now;
      
      const userInfoString = await AsyncStorage.getItem('userInfo');
      if (!userInfoString) {
        return;
      }
      
      const userInfo = JSON.parse(userInfoString);
      const userId = userInfo._id;
      
      if (!userId) {
        return;
      }

      // Construct correct API URL with userId in path  
      const orderApiUrl = `${API_BASE_URL}/api/order/getByUserId/${userId}`;
      console.log('üîç Background checking orders at URL:', orderApiUrl);
      console.log('üîç Background User ID being used:', userId);
      
      const response = await axios.get(orderApiUrl, {
        headers: API_HEADERS,
      });

      console.log('‚úÖ Background Orders API response:', response.data.length, 'orders found');

      if (response.data && response.data.length > 0) {
        const currentOrders = response.data;
        
        // FILTER: Ch·ªâ quan t√¢m 3 tr·∫°ng th√°i c·∫ßn th√¥ng b√°o
        const NOTIFICATION_STATUSES = ['ƒë√£ x√°c nh·∫≠n', 'ƒëang giao', 'giao th√†nh c√¥ng'];
        const ordersForNotification = currentOrders.filter(order => 
          NOTIFICATION_STATUSES.includes(order.status?.toLowerCase())
        );
        
        console.log('üì¶ Background Total Orders:', currentOrders.length);
        console.log('üéØ Background Orders with notification statuses:', ordersForNotification.length);
        console.log('üéØ Background Notification statuses found:', ordersForNotification.map(o => o.status));
        
        // Load saved order statuses ƒë·ªÉ compare changes
        const savedOrderStatusesStr = await AsyncStorage.getItem('orderStatuses');
        const savedOrderStatuses = savedOrderStatusesStr ? JSON.parse(savedOrderStatusesStr) : {};
        
        console.log('üíæ Background Saved order statuses:', Object.keys(savedOrderStatuses).length, 'orders tracked');
        
        // Check for status changes
        const statusChanges = [];
        
        for (const order of ordersForNotification) {
          const orderId = order._id;
          const currentStatus = order.status;
          const savedStatus = savedOrderStatuses[orderId];
          
          // N·∫øu status thay ƒë·ªïi ho·∫∑c order m·ªõi v·ªõi status notification
          if (savedStatus && savedStatus !== currentStatus) {
            console.log(`üîÑ Background Status changed for order ${orderId.slice(-4)}: ${savedStatus} ‚Üí ${currentStatus}`);
            statusChanges.push({
              orderId,
              oldStatus: savedStatus,
              newStatus: currentStatus,
              order: order
            });
          } else if (!savedStatus) {
            console.log(`üÜï Background New order with notification status ${orderId.slice(-4)}: ${currentStatus}`);
            statusChanges.push({
              orderId,
              oldStatus: null,
              newStatus: currentStatus,
              order: order
            });
          }
          
          // Update saved status
          savedOrderStatuses[orderId] = currentStatus;
        }
        
        console.log('üîî Background Status changes detected:', statusChanges.length);

        // Process status changes
        for (const change of statusChanges) {
          const { orderId, oldStatus, newStatus, order } = change;
          
          console.log('üîî Background Creating status change notification for order:', orderId.slice(-4));
          
          // Determine notification title based on status
          let title, message;
          switch (newStatus.toLowerCase()) {
            case 'ƒë√£ x√°c nh·∫≠n':
              title = 'ƒê∆°n H√†ng ƒê√£ X√°c Nh·∫≠n';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n`;
              break;
            case 'ƒëang giao':
              title = 'ƒê∆°n H√†ng ƒêang Giao';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒëang ƒë∆∞·ª£c giao`;
              break;
            case 'giao th√†nh c√¥ng':
              title = 'ƒê∆°n H√†ng Giao Th√†nh C√¥ng';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} ƒë√£ giao th√†nh c√¥ng`;
              break;
            default:
              title = 'C·∫≠p Nh·∫≠t ƒê∆°n H√†ng';
              message = `ƒê∆°n h√†ng ****${orderId.slice(-4)} - ${newStatus}`;
          }
          
          const notification = {
            id: Date.now() + Math.random(),
            type: 'order_status_change',
            title: title,
            message: message,
            orderId: orderId,
            orderStatus: newStatus,
            oldStatus: oldStatus,
            orderTotal: order.total_amount,
            orderItems: order.orderItems?.length || 0,
            timestamp: new Date().toLocaleTimeString('vi-VN'),
            isRead: false,
            createdAt: Date.now()
          };
          
          // Check for duplicate notification
          const currentNotificationsStr = await AsyncStorage.getItem('notifications');
          const currentNotifications = currentNotificationsStr ? JSON.parse(currentNotificationsStr) : [];
          
          const isDuplicate = currentNotifications.some(n => 
            n.orderId === orderId && n.orderStatus === newStatus
          );
          
          if (isDuplicate) {
            console.log('‚ö†Ô∏è Background Status change notification already exists, skipping');
          } else {
            console.log('‚úÖ Background Creating status change notification');
            
            // ALWAYS show SYSTEM notification for order status changes  
            const now = Date.now();
            console.log(`üïí [AUTO-ORDER] Background Time check: Current=${now}, Last=${lastNotificationRef.current}, Diff=${now - lastNotificationRef.current}ms`);
            
            console.log(`üîî [AUTO-ORDER] Background Showing SYSTEM notification for status change: ${title}`);
            console.log(`üîî [AUTO-ORDER] Background About to call showNotificationPopup with notification:`, notification.title);
            console.log(`üîî [AUTO-ORDER] Background Complete notification object:`, JSON.stringify(notification, null, 2));
            
            // ‚úÖ THEO Y√äU C·∫¶U: Internal notification TR∆Ø·ªöC
            console.log(`üì± [STEP 1] Background Adding internal order notification first...`);
            await addNotification(notification);
            
            // ‚úÖ THEO Y√äU C·∫¶U: ƒê·ª£i 1 ch√∫t r·ªìi g·ª≠i system notification
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            try {
              console.log(`üì± [STEP 2] Background Now sending order system notification...`);
              await showNotificationPopup(notification);
              console.log(`‚úÖ [AUTO-ORDER] Background showNotificationPopup completed successfully`);
            } catch (error) {
              console.error(`‚ùå [AUTO-ORDER] Background showNotificationPopup failed:`, error);
            }
            
            console.log(`‚úÖ [COMPLETE] Background Order notification process finished`);
            
            // Update last notification time
            lastNotificationRef.current = now;
          }
        }
        
        // Save updated order statuses
        await AsyncStorage.setItem('orderStatuses', JSON.stringify(savedOrderStatuses));
        console.log('üíæ Background Updated order statuses saved to AsyncStorage');
        
        // If no saved statuses existed before (first time), just initialize tracking
        if (Object.keys(savedOrderStatuses).length === statusChanges.length && statusChanges.every(c => c.oldStatus === null)) {
          console.log('üìù Background First time checking orders - initialized status tracking for', Object.keys(savedOrderStatuses).length, 'orders');
        }
      }
    } catch (error) {
      console.error('‚ùå Error checking for new orders:', error);
      if (error.response) {
        console.error('üìù Error details - Status:', error.response.status);
        console.error('üìù Error details - Data:', error.response.data);
        console.error('üìù Error details - URL:', error.config?.url);
      }
    } finally {
      isCheckingOrdersRef.current = false;
    }
  };

  // Th√™m order ID v√†o danh s√°ch ƒë√£ th√¥ng b√°o
  const addToNotifiedOrderList = async (orderId) => {
    try {
      if (notifiedOrderIds.includes(orderId)) {
        return;
      }
      
      const updatedNotifiedOrderIds = [...notifiedOrderIds, orderId];
      setNotifiedOrderIds(updatedNotifiedOrderIds);
      await AsyncStorage.setItem('notifiedOrderIds', JSON.stringify(updatedNotifiedOrderIds));
    } catch (error) {
      console.error('Error saving notified order ID:', error);
    }
  };

  // Clear danh s√°ch ƒë√£ th√¥ng b√°o (for testing)
  const clearNotifiedList = async () => {
    try {
      setNotifiedProductIds([]);
      setNotifiedOrderIds([]);
      await AsyncStorage.removeItem('notifiedProductIds');
      await AsyncStorage.removeItem('notifiedOrderIds');
    } catch (error) {
      console.error('Error clearing notified list:', error);
    }
  };

  // RESET everything for clean testing
  const resetNotificationSystem = async () => {
    try {
      // Clear all notifications
      setNotifications([]);
      await AsyncStorage.setItem('notifications', JSON.stringify([]));
      
      // Clear notified lists
      setNotifiedProductIds([]);
      setNotifiedOrderIds([]);
      await AsyncStorage.setItem('notifiedProductIds', JSON.stringify([]));
      await AsyncStorage.setItem('notifiedOrderIds', JSON.stringify([]));
      
      // Reset last seen data
      setLastProductCount(0);
      setLastProductIds([]);
      setLastOrderIds([]);
      await AsyncStorage.setItem('lastProductCount', '0');
      await AsyncStorage.setItem('lastProductIds', JSON.stringify([]));
      await AsyncStorage.setItem('lastOrderIds', JSON.stringify([]));
      
      console.log('üîÑ RESET: Complete notification system reset - ready for fresh testing');
    } catch (error) {
      console.error('Error resetting notification system:', error);
    }
  };







  // ‚úÖ CHECK PERMISSION STATUS
  const checkNotificationPermission = async () => {
    try {
      console.log('üîê === PERMISSION CHECK ===');
      
      if (Platform.OS === 'android') {
        const SDK_INT = Platform.constants.Release;
        console.log('üì± Android SDK version:', SDK_INT);
        
        if (SDK_INT >= 13) {
          const status = await PermissionsAndroid.check(PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS);
          console.log('üîê POST_NOTIFICATIONS permission status:', status);
          return status;
        } else {
          console.log('üì± Android < 13, permissions automatic');
          return true;
        }
      } else {
        console.log('üì± iOS permission check not implemented');
        return true;
      }
    } catch (error) {
      console.error('‚ùå Permission check failed:', error);
      return false;
    }
  };

  const value = {
    notifications,
    showPopup,
    currentNotification,
    hidePopup,
    markAsRead,
    markAllAsRead,
    deleteNotification,
    deleteAllNotifications,
    getUnreadCount,
    checkForNewProducts,
    checkForOrderStatusChanges,
    clearNotifiedList,
    resetNotificationSystem,

    checkNotificationPermission,
    requestNotificationPermissions,

    cleanDuplicateNotifications

  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
    </NotificationContext.Provider>
  );
};

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within NotificationProvider');
  }
  return context;
}; 